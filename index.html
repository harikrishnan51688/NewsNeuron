<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SSE POST tester for /chat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    .row { display: flex; gap: 1rem; align-items: center; margin-bottom: .75rem; }
    textarea { width: 100%; height: 5rem; }
    #out, #raw { white-space: pre-wrap; border: 1px solid #ddd; border-radius: 8px; padding: .75rem; min-height: 4rem; }
    #out { background: #f9fafb; }
    #raw { background: #fff; color: #333; }
    button { padding: .5rem .9rem; }
    .muted { color: #666; font-size: .9rem; }
  </style>
</head>
<body>
  <h1>Test SSE (POST) – FastAPI <code>/chat</code></h1>

  <div class="row">
    <label>API URL:</label>
    <input id="url" type="text" size="40" value="http://127.0.0.1:8000/chat">
  </div>

  <div class="row">
    <label>Message(s):</label>
  </div>
  <textarea id="messages">hi</textarea>
  <div class="muted">Enter one message per line; they’ll be sent as <code>{"messages": [...], "stream": true}</code></div>

  <div class="row">
    <button id="start">Start stream</button>
    <button id="stop" disabled>Stop</button>
    <label><input id="showRaw" type="checkbox" checked> Show raw SSE lines</label>
  </div>

  <h3>Accumulated content</h3>
  <div id="out"></div>

  <h3>Raw stream</h3>
  <div id="raw"></div>

  <script>
    const startBtn = document.getElementById('start');
    const stopBtn  = document.getElementById('stop');
    const outEl    = document.getElementById('out');
    const rawEl    = document.getElementById('raw');
    const urlEl    = document.getElementById('url');
    const msgEl    = document.getElementById('messages');
    const showRaw  = document.getElementById('showRaw');

    let controller = null;

    function append(el, text) {
      el.textContent += text;
      el.scrollTop = el.scrollHeight;
    }

    function resetOutput() {
      outEl.textContent = '';
      rawEl.textContent = '';
    }

    startBtn.addEventListener('click', async () => {
      if (controller) return;
      resetOutput();

      const url = urlEl.value.trim();
      const messages = msgEl.value.split('\n').map(s => s.trim()).filter(Boolean);

      controller = new AbortController();
      startBtn.disabled = true;
      stopBtn.disabled = false;

      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: {
            'accept': 'text/event-stream',            // tell server we want SSE
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ messages, stream: true }),
          signal: controller.signal
        });

        if (!res.ok || !res.body) {
          throw new Error(`HTTP ${res.status}`);
        }

        // Stream reader for SSE text
        const reader = res.body.getReader();
        const decoder = new TextDecoder(); // streaming decode handled manually via buffer
        let buffer = '';

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          // SSE frames are separated by a blank line (\n\n). Handle CRLF and chunk splits.
          let index;
          while ((index = buffer.indexOf('\n\n')) >= 0) {
            const frame = buffer.slice(0, index);
            buffer = buffer.slice(index + 2);

            // Show raw if toggled
            if (showRaw.checked) {
              append(rawEl, frame + '\n\n');
            }

            // Parse lines beginning with "data:"
            const lines = frame.split(/\r?\n/);
            for (const line of lines) {
              const m = line.match(/^data:\s*(.*)$/);
              if (!m) continue;

              const payload = m[1];
              // Your server is sending JSON in the data field:
              // data: {"type":"content","data":"Hello!"}
              try {
                const evt = JSON.parse(payload);
                if (evt.type === 'content' && typeof evt.data === 'string') {
                  append(outEl, evt.data);
                } else if (evt.type === 'done') {
                  // Stream finished by server
                  stopStream();
                }
              } catch {
                // Not JSON? Just append the raw string part.
                append(outEl, payload + '\n');
              }
            }
          }
        }

        // Flush any trailing text (in case stream ended without a final blank line)
        if (buffer.trim()) {
          if (showRaw.checked) append(rawEl, buffer);
          const last = buffer.split(/\r?\n/).map(l => l.replace(/^data:\s*/, '')).join('\n');
          append(outEl, last);
        }
      } catch (err) {
        append(outEl, `\n[Error] ${err.message}\n`);
      } finally {
        stopStream(false);
      }
    });

    function stopStream(userInitiated = true) {
      if (controller) {
        if (userInitiated) controller.abort();
        controller = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    stopBtn.addEventListener('click', () => stopStream(true));
  </script>
</body>
</html>
